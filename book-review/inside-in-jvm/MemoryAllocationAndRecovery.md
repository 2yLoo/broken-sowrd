# JVM中的内存分配与回收

> Java与C++之间有一堵由内存动态分配和垃圾收集技术所围成的“高墙”，墙外面的人想进去，墙里面的人想出来。

## 什么是JVM？
JVM（Java Development Kit），Java虚拟机，通过在实际的计算机上仿真模拟各种计算机功能来实现的。我的理解为：我们编写的Java代码，经过编译后成为字节码，以此与JVM交互，再由JVM将其解释给本地系统执行。它是字节码与本地方法的翻译官。我们在不同的平台（Windows、Linux、MacOS等）需要下载不同的JDK，可以理解为与不同语种的人打交道需要不同的字典，由JDK扮演字典的角色。

得益于JVM，Java实现了“Write Once, Run Anywhere”的特性，Java Coder也告别了手动分配、回收内存带来的烦恼。

JVM所管理的内存包括以下几个运行时数据区域：

![JVM内存模型](http://assets.processon.com/chart_image/5ddf8a1be4b00e6d900c8126.png?_=1574933008846)

- 程序计数器：当前线程所执行的字节码行号指示器。字节码工作时通过改变计数器的值来选取下一条需执行的指令。它是以上5大区域中唯一不会发生内存溢出的区域，并且为线程私有。

- Java虚拟机栈：描述的是Java方法执行的内存模型，线程私有。

- 本地方法栈：描述的是Native方法执行的内存模型，线程私有。

- Java堆：用于存放对象实例。垃圾收集的重点照顾区域。从回收角度可将其分为新生代和老年代；其中新生代又可分为Eden空间、From Survivor空间、To Survivor空间等，这在后面会细说。

- 方法区：存储已被JVM加载的类信息、常量、静态变量、即时编译器编译后的代码等数据，在HotSpot中也称为永久代。

了解JVM内存模型，可以帮助我们更好的理解垃圾收集与内存分配操作。

## 垃圾收集器的基石
这座内存动态分配和垃圾收集技术所围成的“高墙”是由无数前辈的智慧结晶凝结而成。要使得垃圾收集自动化，JVM有许多方面需要考虑与判断，例如：

- 哪些内存需要回收？
- 回收的方式有哪些？
- 什么时候进行垃圾收集？

基于以上3个问题，不同的垃圾收集器有不同的解决方案。

### 哪些内存需要回收？
在垃圾回收中，首要确认的问题就是，目标回收的内存是哪些？

在堆中主要存放的都是对象实例，判断对象是否存活有两种方法：
- 引用计数法：给对象添加一个引用计数器，每当有一个地方引用它时，计数器值加1；当引用失效时，计数器值减1；计数器值为0时表示该对象不可能再被使用。

- 可达性分析算法：通过一系列称为“GC Roots”的对象作为起始点，从这些节点开始向下搜索，搜索不到的对象即判定为不可用对象。

引用计数法高效，但存在缺陷：当两个对象互相引用，但这两个对象再无其他引用时，它们已属于可回收对象，但此时两者计数器值均为1，无法被回收。

**Java是通过可达性分析算法判断对象是否存活的** 。

在回收对象时，经过可达性分析算法的筛选后，“濒死”对象还有一丝机会存活：是否有必要执行 `finalize()` 方法，对象可以在 `finalize()` 方法中重新建立与外界的联系，从而存活下来。如果对象没有覆盖 `finalize()` 方法，或者该方法已经被调用过，都会被视为“没有必要执行”，则该对象会被判断为可回收。

**任何一个对象的 `finalize()` 方法都只会被系统自动调用一次** 。

堆是垃圾收集应重点照顾的区域，而除了堆，方法区的内存也可进行垃圾收集。

永久代的垃圾收集主要回收两部分内容：废弃常量和无用的类。

废弃常量很好理解，例如代码 `String s = "abc";` 会将字面量 "abc" 存入永久代中，而当 s 无用后，并且没有其他对象引用了这个字面量，则 "abc" 被称为废弃常量，在永久代进行垃圾回收时会被系统回收。

类需同时满足以下3个条件才算“无用的类”：
- Java堆中不存在该类的实例
- 加载该类的ClassLoader已经被回收
- 该类对应的 `java.lang.Class` 对象没有任何地方被引用，无法在任何地方通过反射访问该类的方法

### 回收的方式有哪些？
在确定好回收目标后，还需要确定回收的方式。新生代对象大多昙花一现，而老年代对象存活率更高，回收算法的选择也因“对象”而异。

- 标记-清除算法：先标记出所有待回收对象，标记完成后统一回收。标记和清除两个步骤的效率都不高；并且容易使内存空间碎片化严重，从而导致内存足够但连续内存不够时，需要再次出发GC。

  ![标记-清除算法](http://assets.processon.com/chart_image/5de0cdf9e4b074c442edd32b.png?_=1575014141158)

- 复制算法：将内存空间划分为两块，每次只用其中之一，当一块内存用完时，触发GC，将还存活对象复制到另一块中。这种算法很适合回收新生代内存，在许多程序中，新生代中的对象数量多，但存活率低，使用此算法能更好的避免空间碎片化。基于此算法，许多JVM将内存划分为一块较大的Eden空间和两块较小的Survivor空间，每次使用Eden和其中一块Survivor，GC时将存活对象一次性复制到另一块Survivor中。

  HotSpot中默认比例为 Eden:Survivor = 8:1。

  当Survivor空间不足时，会请求（注意是请求，而不是直接执行）使用老年代内存进行 **分配担保** 。
  - 分配担保：指当Survivor空间不足以存放上次GC存活下的对象时，将对象直接存到老年代。

  ![复制算法](http://assets.processon.com/chart_image/5de0cc5be4b0e2c29896609e.png?_=1575014483628)

- 标记-整理算法：先将可回收对象进行标记，再将存活对象全向一端移动，从而避免内存空间的碎片化。老年代也在Java堆中，但其中对象存活率高，使用复制算法需划分额外的空间，且复制对象会带来大量的开销，使用此算法更合适。

  ![标记-整理算法](http://assets.processon.com/chart_image/5de0ce8fe4b0e2c29896685e.png?_=1575014474438)

基于以上3种算法，许多JVM都采用“分代收集”策略，对不同类型对内存空间（新生代、老年代）采用不同收集算法。

### 什么时候进行垃圾收集？
在进行可达性分析时，需要暂停所有线程以保证分析期间引用关系不发生变化。这个动作称为“Stop The World”。而可达性分析算法中，可作为GC Roots的节点主要在全局性引用（如常量或静态类属性）与执行上下文（如桢栈中的本地便量表）中，其数量庞大，如果逐个检查里面的引用，会消耗很多时间。

在HotSpot中，采用名为 `OopMap` 的一种数据结构记录特定时刻栈上和寄存器的哪些位置是引用，GC标记开始时，直接从 `OopMap` 获取GC Roots，避免了在全量GC Roots中遍历，达到快速完成可达性分析的目的。

如果为每一条指令都生成对应的 `OopMap` ，需使用大量的额外空间，解决方式是只在“安全点”上生成 `OopMap` 。安全点的选定标准为“是否具有让程序长时间执行的特征”。一般在方法调用、循环跳转、异常跳转等地方产生安全点。

在确定好安全点后，有两种方式可以在GC时让其他工作线程执行到安全点上：抢先式中断与主动式中断。

- 抢先式中断：发生GC时，将所有线程全中断，还没抵达安全点的线程会被恢复，让其执行到安全点再GC。
- 主动式中断：发生GC时，设置一个标志，各线程在执行到安全点时主动轮询该标志，如果需进行GC，则将自己挂起。

但如果某个线程处于Sleep状态或Blocked状态，此时也无法进入安全点，JVM等待其线程执行到安全点是不合理的。此时需要通过安全区域解决。

安全区域是指在一段代码中，引用关系不会发生变化，所以在该区域范围内进行GC都是安全的。

在线程执行到安全区域范围内，不会给GC造成影响。当线程离开安全区域时，若此时发生GC，则需要先等待系统完成GC Roots的枚举（或整个GC过程），才能继续执行。

## HotSpot中的垃圾收集器
不同的垃圾收集器有不同的目标，并且适用于不同的场景与内存区域。下图展示了SpotHot虚拟机中的垃圾收集器。可将其分两类，一类在新生代中使用，一类在老年代中使用。相连的两个收集器表示可以搭配使用。

![HotSpot虚拟机的垃圾收集器](http://assets.processon.com/chart_image/5de0d56ce4b09ddcb608a022.png?_=1575016156930)

### Serial收集器
Serial收集器是一个单线程收集器，在进行GC工作时，会暂停其他所有工作线程，并且由于是单线程的，此时只可以用到一个CPU资源。单线程并不意味着低效，在单核环境中，单线程反而避免了线程切换带来的开销，能更好的利用CPU资源。它是虚拟机运行在Client模式中的默认收集器。

### ParNew收集器
ParNew收集器是多线程版本的Serial收集器。是一款适用于多核环境的 **并行** 收集器。

> 并行：多个垃圾收集线程并行工作，回收进行时用户线程处于等待状态。
>
> 并发：垃圾收集线程与用户线程同时执行，有可能交替执行，或者处于并行状态。

### Parallel Scavenge收集器
它与ParNew收集器很相似：新生代收集器、采用复制算法、并行的多线程收集器。但两者关注点不同。

有两个指标用于衡量一个垃圾收集器的效率：耗时与吞吐量。

吞吐量 = 用户运行时间 / （用户运行时间 + 垃圾收集时间）

耗时短意味着每次STW（Stop The Word）的时间短，用户体验好。吞吐量高则可更高效的利用CPU时间，适用交互少的后台任务。

许多收集器都尽力缩短每次GC的停顿时间，Parallel Scavenge收集器把关注点落在吞吐量上。

### Serial Old收集器
Serial收集器的老年代版本，使用“标记——整理”算法收集老年代空间。

### Parallel Old收集器
Parallel Scavenge收集器的老年代版本，使用多线程“标记——整理”算法收集老年代空间。

### CMS收集器
CMS（Concurrent Mark Sweep）收集器也用于老年代，目标是获取最短回收停顿时间。它基于“标记——清理”算法实现，将垃圾收集划分为4个步骤：

- 初始标记：标记GC Roots能直接关联的对象。
- 并发标记：对GC Roots进行追踪，初步统计可回收对象，可与工作线程并发执行。
- 重新标记：对并发标记期间统计结果产生的变化进行修正。
- 并发清除：清理内存，基于“标记——清理”算法。

其中初始标记与重新标记阶段需要“Stop The Word”，主要耗时工作集中在并发标记和并发清除阶段，由于这两步可以与用户线程并发执行，所以整体停顿的时间会偏少。不过它有3个明显缺点：
- 对CPU资源非常敏感。这是并发垃圾收集器对通病。在2核环境下，CMS需要占用一半的CPU资源来执行收集工作，用户线程的速度降低50%。
- 无法处理浮动垃圾。CMS清理过程中系统也会不断产生新的对象实例，也就产生了新的垃圾，它们在本次清理过程中无法处理，只能留给下一次GC。与其他垃圾收集器不同，CMS不能等到老年代快被填满时再清理，否则无法预留足够的空间给用户线程。当预留空间无法满足用户线程当需求时，产生“Concurrent Mode Failure”，并临时采用Serial Old收集器重新收集老年代垃圾。
- 产生大量空间碎片。这因为CMS收集器是基于“标记——清理”算法实现，在该算法下，未被回收的对象地址不变，因此在CMS第4步并发清除阶段才可实现“并发”。当碎片化严重导致无法分配给大对象时，可以通过参数 `-XX:+UseCMSCompactAtFullCollection` （默认开启）开启内存碎片的合并整理，不过该步骤无法并发执行，会使停顿时间变长。

### G1收集器
G1（Garbage-First）收集器将Java堆分为多个大小相等的独立区域（Region），从逻辑上划分新生代和老年代，它们都是Region的集合，之间不存在物理隔离。

G1收集器的特点为：并行与并发、分代收集、空间整合、可预测的停顿。

G1跟踪各个Region的垃圾堆积状况，在后台维护一个优先列表，每次根据收集时间优先回收价值最大的Region。

而分区后，每个区域中的对象都可能和其他区域中的对象建立引用关系，Region之间不是孤立的。JVM通过使用 `Remembered Set` 来避免全堆扫描。如果对区域A进行写操作，新增了一个对区域B中某个对象对引用，会先把相关引用信息同步到区域B的 `Remembered Set` 中。回收时，在GC跟节点的枚举范围中加入 `Remembered Set` 即可保证不对全堆扫描也不会有遗漏。

不计算维护 `Remembered Set` 操作，G1收集器可分为以下4步：
- 初始标记：标记GC Roots能直接关联的对象。
- 并发标记：通过可达性分析算法找出存活对象，可与用户程序并发执行。
- 最终标记：修正并发标记中变动的标记记录。
- 筛选回收：根据优先列表回收部分Region中的内存。

### 垃圾收集器参数
GC涉及到到细节有很多，下面是部分GC控制的JVM参数：

| 参数                           | 描述                                                                                          |
| ------------------------------ | --------------------------------------------------------------------------------------------- |
| UseSerialGC                    | JVM运行在Client模式下的默认值，使用Serial + Serial Old收集器回收内存                          |
| UseParNewGC                    | 使用ParNew + Serial Old收集器回收内存                                                         |
| UseConcMarkSweepGC             | 使用ParNew + CMS + Serial Old收集器回收内存，其中 Serial Old 用于帮助CMS处理浮动垃圾问题      |
| UseParallelGC                  | JVM运行在Server模式下的默认值，使用 Parallel Scavenge + Serial Old收集器回收内存              |
| UseParallelOldGC               | 使用Parallel Scavenge + Parallel Old收集器回收内存                                            |
| SurvivorRatio                  | 控制新生代中Eden区域与Survivor区域的容量比值，默认值为8，Eden : Survivor = 8:1                |
| PretenureSizeThreshold         | 控制晋升到老年代的对象大小，设置后，大于该大小的对象直接分配到老年代                          |
| MaxTenuringThreshold           | 控制晋升到老年代的对象年龄，默认值为15，每个对象坚持过一次Minor GC后年龄升1，超过该值时进入老年代         |
| UseAdaptiveSizePolicy          | 动态调整Java堆中各个区域的大小和进入老年代的年龄                                              |
| HandlePromotionFailure         | 是否允许担保失败                                                                              |
| ParallelGCThreads              | 控制并行GC时垃圾收集的线程数                                                                  |
| GCTimeRatio                    | 控制GC时间占总时间比率，默认值为99，允许1%的GC时间，用于Parallel Scavenge收集器               |
| MaxGCPauseMillis               | 控制GC最大停顿时间，用于Parallel Scavenge收集器                                               |
| CMSInitaitingOccupancyFraction | 控制CMS收集器在老年代空间触发GC的容量比例阈值，默认值为68%，用于避免在CMS中发生Serial Old收集 |
| UseCMSCompactAtFullCollection  | 控制CMS收集器完成GC后是否要进行一次内存碎片整理                                               |
| CMSFullGCsBeforeCompaction     | 控制CMS收集器在多少次GC后再进行内存整理                                                                                              |

## 内存的分配与回收
两个概念：
- 新生代GC（Minor GC）：发生在新生代的GC，在程序中Minor GC会比较频繁，回收速度也比较快。
- 老年代GC（Major GC/Full GC）：发生在老年代的GC，回收速度较慢。

大多数情况下，对象会被分配到新生代到Eden区中，当Eden空间不够时发起一次Minor GC回收新生代的内存。

而大对象不适合分配到新生代，因为新生代采用复制算法，GC频繁，应避免Eden区与两个Survivor区之间对大量内存复制。

每经历一次Minor GC，存活对象的年龄就会加1，当对象达到一定年龄（默认15），则会被晋升到老年代中。

除了真正的“老”对象会进入老年代，还有另一种方式。如果Survivor空间中相同年龄所有对象大小的总和大于Survivor空间的一半，年龄大于或等于改年龄的对象就会直接进入老年代。

GC的流程判断可大致总结如下：

![GC内存分配流程](http://assets.processon.com/chart_image/5dd79dcee4b0f3097999fe9c.png?_=1575270273348)

其中有许多细节需要考虑，因为Full GC比Minor GC更耗时，应尽量避免没必要的Full GC，以缩减GC带来的停顿。

下面以避免Minor GC后还要进行Full GC为目标盘点几个流程图中的细节：

1. 在发生Minor GC前，需判断老年代 **连续可用空间** 是否大于新生代所有对象的总空间。以防极端情况下，Minor GC后，所有对象都需要迁移到老年代时空间不够，而触发Full GC。

2. 如果第一步判断老年代在极端情况下连续空间不够，则再判断是否允许担保失败。如果不允许，只好进行Full GC。

3. 如果允许担保失败，还是有机会绕开Full GC的。评估Minor GC后Full GC的概率，即比较老年代剩余空间与历次晋升到老年代时对象总大小的平均值，如果老年代空间大于此平均值，则“打赌”此次Minor GC所存活的对象即使放在老年代空间也是足够的。

其实这三步都无法影响当下Java堆的使用情况，但至少可以直接Full GC，而不用等Minor GC之后才后知后觉的Full GC。

## 总结
作为后辈，能站在巨人的肩膀上往往能事半功倍，而对JVM了解得更多，可以帮助我们更好解决实际问题。JVM的内存回收与分配就像海面上的冰山，我们接触的只是很小的一部分。没有固定的收集器、参数组合，也没有普遍适用的调优方式，未来更优秀的收集器，需要更多人用更多的智慧联结起来，就像海平面，往往微不足道的进步是需要巨量的填充。

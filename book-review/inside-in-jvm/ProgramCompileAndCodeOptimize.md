# 程序编译与代码优化

## 编译期优化

根据处理目标与处理结果的不同可将编译器分为3类：

- 前端编译器：Sun的Javac，将Java代码转换成字节码。
- JIT编译器：HotSpot VM的C1、C2编译器，将字节码转换成机器码
- AOT编译器：GNU Compiler for the Java（GCJ）、Excelsior JET，将Java代码直接转换成机器码。

![编译器类型](http://assets.processon.com/chart_image/5e1593fce4b0bcfb733a18cd.png?_=1578472729528)

其中前端编译器在编译期的优化过程与程序编码关系密切，Javac做了许多针对Java语言编码过程的优化措施来改善程序员的编码风格和提高编码效率。

JIT编译器在运行期的优化过程对程序运行至关重要，虚拟机设计团队把对性能的优化集中到了JIT编译器中，也称为即时编译器。

### Javac编译器
Javac编译器是前端编译器中的一种，目的是将Java代码编译为字节码，它的编译步骤可大致分为3个过程： **解析与填充字符标** 、 **注解处理** 、 **分析与字节码生成** 。

![Javac的编译过程](http://assets.processon.com/chart_image/5e15973ae4b079d58d1c80b6.png)

#### 解析与填充字符表
在这个步骤中，会进行 **词法分析** 、 **语法分析** ，并 **填充符号表** 。

词法分析是将源代码（Java代码）的字符流转变为标记（Token）集合，标记是编译过程的最小元素，关键字、变量名、字面量、运算符都可成为标记，在代码 `int age = 18;` 中有4个标记： `int` 、 `age` 、 `=` 以及 `18` 。

语法分析是根据Token序列构造抽象语法树的过程，抽象语法树是一种用来描述程序代码语法结构的树形表示方式，语法树的每一个节点都代表着程序代码中的一个语法结构，例如包、类型、修饰符、运算符、接口、返回值甚至代码注释都可以是一个语法树结构。经过语法分析后，编译器就基本不会再操作源码文件（.java文件）了，源码文件的内容被加载到内存中，用于后续编译。

接下来需要填充符号表，符号表是一组符号地址和符号信息构成的表格。它用于语义检查以及产生中间代码，符号表也是目标代码生成阶段地址分配的依据。

#### 注解处理器
Java在1.5版本支持注解功能，注解处理器可以读取、修改、添加抽象语法树中的任意元素，如果处理注解期间对语法树进行了修改，则编译器会返回到前一步解析与填充字符表的过程重新处理。

#### 语义分析与字节码生成
在前两步完成后，需要验证语法树的语义是否正确。因为语法树虽然可以表示源程序，但是不保证源程序符合逻辑，语义分析分为 **标注检查** 和 **数据及控制流分析** 两步。

标注检查步骤会检查变量使用前是否已声明、变量与赋值之间的数据类型是否匹配等，还会进行常量折叠，例如 `int a = 1 + 2;` 中，通过常量折叠，代码会被定义为 `int a = 3;` 。

数据及控制流分析是对程序上下文逻辑进一步的验证，如检查局部变量使用前是否有赋值、方法的每条路径是否都有返回值、受检查异常是否被正确处理等。

但是 **编译器不会校验方法局部变量中的的 `final` 语义** 。下面两个不同的方法编译出来的字节码是相同的：
```
public void method(final int arg) {
    final int var = 0;
    // do someting
}


public void method(int arg) {
    int var = 0;
    // do someting
}
```

`final` 语义仅由编译器在编译期间保障。

#### 解语法糖
语法糖指在计算机语言中添加的某种语法，这种语法对语言的功能没有影响，仅使程序员编写时更加方便。Java中最常用的语法糖包括泛型、变长参数、自动装箱/拆箱等，虚拟机运行时并不支持这些语法，它们在编译阶段被还原为基础语法结构，这个过程称为解语法糖。

#### 字节码生成
在字节码生成阶段，前面各个步骤所生成的信息（语法树、符号表）被转化为字节码写到磁盘中，编译器还会进行少量的代码添加与转换工作。如实例构造器 \<init>()方法和类构造器 \<clinit>()方法。

我们需要区分开实例构造器方法、类构造器方法与我们自定义的构造器方法：
```
public class MainClass {

    static {
        // 该代码会被添加到 <clinit>() 方法中
        System.out.println("类构造器方法");
    }

    {
        // 该代码会被添加到 <init>() 方法中
        System.out.println("实例构造器方法");
    }

    public MainClass() {
        // 该代码不会被添加到 <clinit>() 和 <init>() 方法中
        System.out.println("自定义构造器方法");
    }

    public static void main(String[] args) {
        MainClass mainClass = new MainClass();
    }

}
```

### Java语法糖
语法糖可以方便程序员的代码开发，它们不会提升实质性的运行性能，但可以利用它提高生产效率，减少代码出错的机会。

#### 泛型语法糖
泛型的本质是参数化类型的应用，在Java中可应用在类、接口和方法的创建中。如常用的集合接口 `List<T>` 。

泛型的实现可分为两种：
- 基于类型膨胀实现的泛型称为真实泛型，在这种实现方式下，List\<int>与List\<String>是两个不同的类型，它们在系统运行期生成，有自己的虚方法表和类型数据，代表语言为C#。
- 基于类型擦除实现的泛型称为伪泛型，在这种实现方式下，List\<int>与List\<String>是同一个类型，泛型的具体类型经过编译后被转换为原生类型，并在相应的地方插入了强制转型代码，实际上是一颗语法糖，代表语言为Java。

#### 自动装箱、拆箱与遍历循环
在Java中，8大基础类型byte、short、int、long、float、double、char、boolean分别对应了8个包装类：Byte、Short、Integer、Long、Float、Double、Character、Boolean。

以int为例，装箱是通过Integer的类方法 `valueOf()` 将基础类型int的值转换成一个Integer对象，拆箱是通过Integer的实例方法 `intValue()` 将对象转换为int值。

如果不使用自动装箱的语法糖，下面代码看起来会很繁琐：
```
public void method() {
    List<Integer> list = Arrays.asList(Integer.valueOf(1),
        Integer.valueOf(2));
    // do someting
}
```

利用该语法糖特性，程序员可以更简洁、高效的敲代码：
```
public void method() {
    List<Integer> list = Arrays.asList(1,2);
    // do someting
}
```

装箱类型与基础类型最大的差别，我认为是其初始值：Integer的初始值为null，而int的初始值为0。

还需要注意两点：
1. **Java缓存了值在[-128, 127]之间的包装类对象** ，创建两个值在此区间的Integer对象时，只会返回同一个对象，否则返回两个不同对象。
  ```
  public static void main(String[] args) {
      Integer a = 127;
      Integer b = 127;
      Integer c = 128;
      Integer d = 128;
      System.out.println(a == b); // a、b实际为同一个对象，结果输出true
      System.out.println(c == d); // c、d实际为两个对象，结果输出false
  }
  ```

2. **包装类的“==”运算只有在遇到算数运算的情况下才会自动拆箱** 。
  ```
  public static void main(String[] args) {
      Integer a = 200;
      Integer b = 100;
      Integer c = 300;
      Integer d = 300;
      System.out.println(c == (a + b)); // c被拆箱为int值300，结果输出true
      System.out.println(c == d); // c未被拆箱，c、d实际为不同对象，结果输出false
  }
  ```

我们经常使用foreach语法糖进行遍历：
```
public static void main(String[] args) {
    List<String> list = Arrays.asList("a", "b", "c", "d");
    for (String e : list) {
        System.out.println(e);
    }
}
```

经过解语法糖，上面代码会变成这样：
```
public static void main(String[] args) {
    List<String> list = Arrays.asList("a", "b", "c", "d");
    for (Iterator localIterator = list.iterator(); localIterator.hasNext(); ) {
        System.out.println((String) localIterator.next());
    }
}
```

如果我们想在自己实现的类上使用foreach循环，只需将其实现Iterable接口即可，在下面的代码中，MyList通过foreach循环访问索引为偶数的元素：
```
public class MainClass {

    public static void main(String[] args) {
        String[] arr = {"a", "b", "c", "d", "e"};
        MyList list = new MyList(arr);
        for (String str : list) {
            System.out.println(str);
        }
    }

    static class MyList implements Iterable<String> {
        private String[] arr;
        private int now = 0;

        public MyList(String[] arr) {
            this.arr = arr;
        }

        @Override
        public void forEach(Consumer<? super String> action) {

        }

        @Override
        public Spliterator<String> spliterator() {
            return null;
        }

        @Override
        public Iterator<String> iterator() {
            return new Iterator<String>() {
                @Override
                public boolean hasNext() {
                    boolean result = now <= arr.length - 1;
                    if (!result) {
                        now = 0;
                    }
                    return result;
                }

                @Override
                public String next() {
                    String result = arr[now];
                    now += 2;
                    return result;
                }
            };
        }
    }

}
```

## 运行期优化
即时编译器编译性能的好坏、代码优化程度的高低是衡量虚拟机优秀与否的最关键指标之一，它也是虚拟机中最核心且最能体现虚拟机技术水平的部分。

### HotSpot中的即时编译器
在HotSpot架构中，使用解释器与编译器互相配合工作。它们都将字节码转换为本地机器码，但是使用场景不同。解释器耗时较短，每要立即执行一个字节码方法时，就将其解释为机器码并执行。编译器耗时较长，当某个“热点代码”被多次执行后，由编译器将其编译为本地机器码，在下一次调用时，直接使用该机器码，从而省去每次解释的时间与空间消耗。

#### C1还是C2
编译器又分为Client Compiler（C1）与Server Compiler（C2）。C1关注于局部性的优化，编译速度更高；C2是专门面向服务端端典型应用，它编译所需要的时间更长，但编译输出的代码质量更高，可以减少本地代码的执行时间。

HotSpot虚拟机会根据自身版本与宿主机硬件性能自动选择运行模式，如果用户指定虚拟机运行在Client模式，解释器则与C1配合工作，对应的在Server模式下解释器与C2配合工作。

虚拟机会采用分层编译策略，来平衡程序启动响应速度与运行效率。

分层编译根据编译器编译、优化的规模与耗时，划分出不同的编译层次，使用解释器与C1、C2互相配合工作：
- 第0层，程序解释执行，解释器不开启性能监控功能。
- 第1层，使用C1将字节码编译为本地代码，进行简单、可靠的优化，如有必要将加入性能监控的逻辑。
- 第2层（或2层以上），使用C2将字节码编译为本地代码，会启动一些编译耗时较长的优化。

#### 方法调用计数器
被编译器编译的“热点代码”包括两类：被多次调用的方法和被多次执行的循环体。

判断一段代码是否为“热点代码”，有两种主要方式：
- 基于采样的热点探测：虚拟机周期性地检查各个线程的栈顶，如果某个方法经常出现在栈顶，则为“热点方法”。这样实现简单，但结果不精确，会受到线程阻塞等因素的干扰。
- 基于计数器的热点探测：使用计数器统计每个方法的执行次数，超过一定阈值则为“热点方法”。HotSpot采用了这种机制，并通过两种计数器实现统计热度：方法调用计数器与回边计数器。

方法调用计数器统计方法的调用次数，用于触发方法的JIT编译。

当方法的调用次数与回边计数器之和超过阈值，将会向编译器提交一个编译该方法代码的请求。

![方法调用计数器触发步骤](http://assets.processon.com/chart_image/5e168908e4b0f5a7ed066b3d.png?_=1578536178059)

方法的热度会随时间衰减，当超过一定时间限度，方法调用次数仍然无法达到阈值，则该方法的调用计数器就会减少一半，热度衰减的动作在虚拟机进行垃圾回收时进行，可以通过虚拟机参数 -XX:-UseCounterDecay关闭热度衰减，或者通过 -XX:CounterHalfLifeTime设置半衰周期时间。

#### 回边计数器
回边计数器统计方法中循环体代码执行的次数，用于触发循环体的OSR（On Stack Replacement，在栈上替换编译对象）编译。

![回边计数器触发步骤](http://assets.processon.com/chart_image/5e168c33e4b009af4a65088b.png?_=1578536193684)

回边计数器的计数值不会衰减，其值代表该方法循环执行的绝对次数。

**无论是JIT编译还是OSR编译，虚拟机在代码编译器还未完成之前，都仍然将按照解释方式继续执行，编译动作在后台的编译线程中进行。**

### 编译优化技术
通过编译优化技术，可以使得编译后得到的本地代码比实时解释字节码得到的本地代码质量更高，这也是Java并不一定比C/C++等语言慢的一个重要原因。

#### 公共子表达式消除
这是一种和语言无关的经典优化技术，它的含义为：如果一个表达式E已经计算过了，并且从先前的计算到现在E中的所有变量的值都没有发声变化，那么E在下次出现时不需要重新计算，直接使用之前计算得到的结果即可。

例子：
```
int d = (c * b) * 12 + a + (a + b * c);
```

在上面代码中， `(c * b)` 属于一个公共子表达式，原表达式可视为：
```
int d = E * 12 + a + (a + E);
```

再继续简化，可以变得更简单：
```
int d = E * 13 + a * 2;
```

#### 数组边界检查擦除
Java是动态安全的语言，在访问数组 `arr[]` 的第i（以第0位开始计数）个元素时，如果索引i的值不在[0, arr.length-1]内，则会抛出一个运行时异常。

这对开发者很方便，但如果虚拟机需要在每次对数组元素的读写访问都隐式地进行一次边界检查，也会成为Java语言的性能负担。在一些情况下，在编译器通过对数据流地分析，可以确定下标（索引）是否未越界，从而在执行时无须再次判断。

类似的运行期检查还有除数不可为零、访问对象属性时对象不可为null等。

除了将运行期检查提前放到编译器完成，还可使用隐式异常处理的方式。

以访问对象属性为例的伪代码：
```
if  (foo != null) {
    return foo.value;
} else {
    throw new NullPointException();
}
```

通过隐式异常优化，伪代码会转变为以下形式：
```
try {
    return foo.value;
} catch (segment_fault) {
    uncommon_trap;
}
```

这样做好处是在正常访问foo.value时减少了一次非空判断，但其缺点也很明显，当foo对象真为空时，其捕获并处理异常的速度远比一次非空判断慢。HotSpot的做法是通过收集Profile信息灵活地选择最优方案，从而避免固定某种方案带来的困扰。

#### 方法内联
方法内联：将方法内调用的其他方法直接内嵌到该方法内部，避免发生真实的方法调用。

方法内联消除了方法调用的成本，并为其他优化手段建立了良好的基础。但Java中实例方法默认为虚方法，虚方法需要依赖上下文确定其执行的目标对象，会困扰方法内联的落地。Java虚拟机设计团队引入了名为“类型继承关系分析”（Class Hierarchy Analysis, CHA）的技术，基于整个应用的类型分析，确定目前已加载的类中，某个接口是否有多个实现，某个类是否存在子类、子类是否为抽象类等信息。

![方法内联优化步骤](http://assets.processon.com/chart_image/5e16ef0fe4b0bcfb733cae2b.png?_=1578562182791)

编译器进行内联时，如果是非虚方法，则可以直接内联，如果是虚方法，则通过CHA查询该方法在当前程序下是否有多个版本可选，如果只有一个版本，也可内联，如果后续过程中，该方法版本的唯一性不发生改变，则通过内联优化的代码可以一直使用下去，否则需要抛弃已编译的代码，退回到解释状态执行，或者重新编译。

如果CHA查询到该方法有多个版本可选，则使用内联缓存来完成方法内联。内联缓存在发生调用时，记录方法接收者的版本信息，在每次进行方法调用时比较接收者版本，如果版本相同则直接使用，否则说明程序使用了虚方法的多态特性，这时会取消内联，查找虚方法表进行方法分派。

#### 逃逸分析
逃逸分析并不是一种优化代码的手段，而是为其他优化手段提供的一种分析技术。逃逸分析会分析对象动态作用域：当一个对象在方法中被定义，但被外部方法所引用，则称为方法逃逸；当对象可被外部线程访问到，则称为线程逃逸。

在Java中，数据存储在不同的对象里，如果对象并没发生方法逃逸或线程逃逸，则可针对性的进行一些更极致的优化。

标量替换就是其中的一种优化方案：标量是指一个数据已经无法再分解成更小的数据来表示，在Java虚拟机中的原始数据类型（int、long、reference等）就是标量，标量替换是指将Java对象拆散成标量，并将其使用到的成员变量恢复原始类型来访问。如果一个对象不会被外部访问，则可以通过标量替换将成员变量（数据）放到栈上读写，还可为后续进一步的优化手段创建条件。

### Java与C/C++编译器对比
Java常被人认为是执行缓慢的一种语言。其中主要原因之一是因为比起C/C++等编译型语言，Java作为一种解释型语言，程序执行多了一个解释的动作。

Java虚拟机的即时编译器与C/C++的静态优化编译器相比，可能会由于下列原因导致输出的本地代码有一些劣势：
1. 即时编译器运行占用的是用户程序的运行时间，它能提供的优化手段也严重受制于编译成本。
2. Java作为动态的类型安全语言，需要由虚拟机确保程序不会违反语义或访问非结构化内存。这部分工作包括空指针检查、数组元素上下界范围检查、类型转换时继承关系检查等。
3. 由于Java使用虚方法的频率远远大于C/C++。虚拟机中编译器进行一些优化时（如方法内联），其实现难度更高。
4. Java语言可动态扩展，运行时加载新的类可能改变程序类型的继承关系，使得许多全局的优化难以进行。编译器无法掌控程序的全貌，一些全局的优化措施只能已激进优化的方式完成，而编译器必须时刻注意类型的变化，以在运行时撤销或重新进行一些优化。
5. Java语言中对象的内存分配在堆上，只有方法中的局部变量才能在栈上分配，使得垃圾回收的难度和压力更大。

但这无法否认Java是一种开发效率很高的编程语言，它开发效率的优势是建立在动态安全、动态扩展、垃圾回收等使得它更慢的特性上。
